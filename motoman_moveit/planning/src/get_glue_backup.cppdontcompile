#include <ros/ros.h>
#include <geometry_msgs/Pose.h>
#include <motoman_moveit/move_group_serverRequest.h>
#include <motoman_moveit/move_group_serverResponse.h>
#include <apc_vision/ObjectDetectRequest.h>
#include <apc_vision/ObjectDetectResponse.h>
#include <grasp_logic/graspRequest.h>
#include <grasp_logic/graspResponse.h>
#include <iostream>

int main(int argc, char **argv) {
    ros::init(argc, argv, "right_target_pose");
    ros::NodeHandle node_handle;  
    ros::AsyncSpinner spinner(4);
    spinner.start();
    
    // activate gripper
    // ADD LATER
    
    // move to pose in front of bin
    motoman_moveit::move_group_serverRequest moveBinReq;    
    motoman_moveit::move_group_serverResponse moveBinRes;    

    geometry_msgs::PoseStamped target_pose_stamped;    
    geometry_msgs::Pose target_pose;
    target_pose.position.x = ;
    target_pose.position.y = ;
    target_pose.position.z = ;
    target_pose.orientation.x = ;
    target_pose.orientation.y = ;
    target_pose.orientation.z = ;
    target_pose.orientation.w = ;

    target_pose_stamped.pose = target_pose;

    moveBinReq.pose = target_pose_stamped;
    moveBinReq.arm = "arm_left";

    ros::service::call("move_group_service", moveBinReq, moveBinRes);
    
    if (!moveBinRes.success) {
		std::cout << "move_group_service service returned failure" << "/n";
		return 0;
	}
    
    // call vision service
    apc_vision::ObjectDetectRequest detectReq;
    apc_vision::ObjectDetectResponse detectRes;

    detectReq.bin = "D";
    detectReq.object = "elmers_washable_no_run_school_glue";

    ros::service::call("object_detect", detectReq, detectRes);
    
    if (!detectRes.success) {
		std::cout << "object_detect service returned failure" << "/n";
		return 0;
	}

    // call grasp logic service
    grasp_logic::graspRequest graspReq;
    grasp_logic::graspResponse graspRes;

    graspReq.object = "elmers_washable_no_run_school_glue";
    graspReq.obj_pose = detectRes.pose;

    ros::service::call("grasp_logic", graspReq, graspRes);

    // move to object    
    motoman_moveit::move_group_serverRequest moveObjectReq;   
    motoman_moveit::move_group_serverResponse moveObjectRes;   

    moveObjectReq.pose = grasp.response.arm_pose;
    moveObjectReq.arm = "arm_left";

    ros::service::call("move_group_service", moveObjectReq, moveObjectRes);
    
    if (!moveBinRes.success) {
		std::cout << "move_group_service service returned failure" << "/n";
		return 0;
	}


    // call gripper (close) service
    // ADD LATER

    // move up
    motoman_moveit::move_group_server moveUp;   

    moveUpReq.pose = graspRes.arm_pose;
    moveUpReq.pose.pose.position.z += 0.02;    
    moveUpReq.arm = "arm_left";

    ros::service::call("move_group_service", moveUpReq, moveUpRes);
    
    if (!moveUpRes.success) {
		std::cout << "move_group_service service returned failure" << "/n";
		return 0;
	}

    // move out (to same pose in front of bin)
    ros::service::call("move_group_service", moveBinReq, moveBinRes);
    
    if (!moveBinRes.success) {
		std::cout << "move_group_service service returned failure" << "/n";
		return 0;
	}

    // move to order box
    motoman_moveit::move_group_serverRequest moveBoxReq;   
    motoman_moveit::move_group_serverResponse moveBoxRes;   

    geometry_msgs::PoseStamped box_pose_stamped;    
    geometry_msgs::Pose box_pose;
    box_pose.position.x = ;
    box_pose.position.y = ;
    box_pose.position.z = ;
    box_pose.orientation.x = ;
    box_pose.orientation.y = ;
    box_pose.orientation.z = ;
    box_pose.orientation.w = ;

    box_pose_stamped.pose = box_pose;

    moveBoxReq.pose = box_pose_stamped;
    moveBoxReq.arm = "arm_left";

    ros::service::call("move_group_service", moveBoxReq, moveBoxRes);
    
    if (!moveBoxRes.success) {
		std::cout << "move_group_service service returned failure" << "/n";
		return 0;
	}


    // call gripper (open) service
    // ADD LATER


}
